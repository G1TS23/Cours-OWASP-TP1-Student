# TP - Rapport de Recherche de Vuln√©rabilit√©s et Rem√©diations

## 1. Informations G√©n√©rales

- **Nom / Bin√¥me : Pierre LE POTTIER & Olivier FALAHI**
- **Date: 6 juin 2025**

---

## 2. M√©thodologie

- **Analyse statique :**
    - Lecture rapide du code backend (TypeScript) et frontend (Vue).
    - Rep√©rage des routes critiques et de la configuration Express.
    - Inspection de la gestion des sessions, des acc√®s, des requ√™tes SQL et des composants Vue (v-html, etc.).
- **Tests dynamiques :**
    - Lancement local de l‚Äôapplication (npm run setup puis npm run dev).
    - Utilisation de Postman pour s‚Äôauthentifier (POST /api/auth/login) et rejouer les requ√™tes.
    - Modifications d‚ÄôURL et de param√®tres pour v√©rifier les contr√¥les d‚Äôacc√®s et tenter des injections.
    - Observation des cookies et des en‚Äët√™tes via les outils de d√©veloppement du navigateur.

---

## 3. Vuln√©rabilit√©s Identifi√©es

### 3.2. Broken Authentication

- **Localisation :** configuration de session dans `backend/src/index.ts` et contr√¥leur `auth.ts`
  ```ts
    app.use(cors({
    origin: process.env.NODE_ENV === 'production'
    ? `https://localhost:${httpsPort}`
    : `http://localhost:8080`,
    credentials: true
    }));
    
    app.use(session({
    store: new SQLiteStore({
    db: 'sessions.db',
    dir: './data',
    expires: 1 * 60 * 60, // 1 heure
    }),
    secret: 'secret-key',
    resave: false,
    saveUninitialized: false,
    name: 'session',
    }));
  ```

  ```ts
    // Inscription
    export async function register(req: Request, res: Response): Promise<any> {
    const { username, password } = req.body;
    await db.run(
    `INSERT INTO users (username, password, role) VALUES (?, ?, 'user')`,
    username, password
    );
    res.status(201).json({ message: 'User registered' });
    }
    
    // Connexion
    export async function login(req: Request, res: Response): Promise<any> {
    const { username, password } = req.body;
    const user = await db.get(`SELECT * FROM users WHERE username = ?`, username);
    if (!user) return res.status(401).json({ error: 'User not exist' });
    if (user.password !== password) return res.status(401).json({ error: 'Invalid password' });
    req.session.user = { id: user.id, role: user.role };
    res.json(user);
    }
    
    // D√©connexion
    export async function logout(_req: Request, res: Response): Promise<any> {
    res.clearCookie('session').json({ message: 'Logged out' });
    }
  ```
- **Preuve de concept :**
    1. Fixation de session : se connecter une premi√®re fois et noter la valeur du cookie session. Se reconnecter : la
       valeur est identique.
    2. Absence de s√©curit√© : le cookie n‚Äôayant pas le flag secure, il transite en clair en HTTP (mode dev).

![cookie-no-change-and-no-secure.png](screenshoots/cookie-no-change-and-no-secure.png)

- **Cause :**
    - Le secret de session est cod√© en dur et aucune option de cookie
    - Aucune r√©g√©n√©ration de session apr√®s connexion ; aucune destruction de session lors du logout

- **Rem√©diation :**
    - Lire le secret depuis `process.env.SESSION_SECRET`
    - Configurer les cookies :
      ```ts
      cookie: { httpOnly: true, secure: true, sameSite: 'strict' }
      ```
    - Utiliser `req.session.regenerate()` apr√®s authentification et `req.session.destroy()` au logout

---

### 3.3. Sensitive Data Exposure

- **Localisation :** mots de passe en clair dans `backend/src/database/seed.ts` et donc pas de hash + les routes login
  et me renvoient √©galement ce champ + les messages d'erreurs lors du login trop pr√©cis dans contr√¥leur `auth.ts`
  ```ts
    const usersData = [
    { username: 'alice',  password: 'N15J9VLiyTmL', role: 'user'  },
    { username: 'bob',    password: '123456',      role: 'user'  },
    { username: 'admin',  password: 'H3qWu6w1Nzkm', role: 'admin' },
  ```

![mot-de-passe-no-hash.png](screenshoots/mot-de-passe-no-hash.png)

  ```ts
  if (!user) return res.status(401).json({error: 'User not exist'});
if (user.password !== password) return res.status(401).json({error: 'Invalid password'});
  ```

![erreurs-explicites.png](screenshoots/erreurs-explicites.png)

- **Preuve de concept :**
    1. Lancer npm run setup puis ouvrir data/database.db : la table users contient des mots de passe en clair.
    2. Appeler GET http://localhost:3000/api/auth/me : le mot de passe est pr√©sent dans la r√©ponse.

- **Cause :**
    - Pas de hash du mot de passe
    - Renvoi du mot de passe lors du login
    - Renvoi d'une erreur trop explicite

- **Rem√©diation :**
    - Stocker un hash bcrypt au lieu du mot de passe
    ```ts
      const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);
    ```
    - Comparer via `bcrypt.compare` √† la connexion et ne jamais renvoyer ce champ
    - Ne pas diff√©rencier un username invalide d'un mot de passe invalide dans la gestion des erreurs renvoy√©es

---

### 3.5. Security Misconfiguration

- **Localisation :** cors et autres dans `backend/src/index.ts`
  ```ts
  app.use(cors({
  origin: process.env.NODE_ENV === 'production'
  ? `https://localhost:${httpsPort}`
  : `http://localhost:8080`,
  credentials: true
  }));
  ```

  ```ts
  if (process.env.NODE_ENV !== 'production') {
  http.createServer(app).listen(devPort, () => console.log(`üîì HTTP Server (dev) on http://localhost:${devPort}`));
   ```

- **Cause :**
    - L‚Äôorigine est fix√©e √† http://localhost:8080 sans contr√¥le suppl√©mentaire
    - La ligne http.createServer permet un downgrade en HTTP ; aucun en‚Äët√™te HSTS ne force le HTTPS
    - Pas de middleware helmet : les en‚Äët√™tes de s√©curit√© par d√©faut sont absents

- **Rem√©diation :**
    - Restreindre CORS via une whitelist
    ```ts
  const whitelist = process.env.CORS_WHITELIST ? process.env.CORS_WHITELIST.split(',') : [];

  app.use(cors({
    origin: function (origin, callback) {
      if (!origin) return callback(null, true);

      if (whitelist.indexOf(origin) !== -1) {
        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials: true
  }));
    ```
    - Activer HSTS en production
    ```ts
  if (process.env.NODE_ENV !== 'production') {
    http.createServer(app).listen(devPort, () => console.log(`üîì HTTP Server (dev) on http://localhost:${devPort}`));
  } else {
    app.use((req, res, next) => {
      res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
      next();
    });
   ```
    - Installer helmet
    ```ts
      app.use(helmet());
    ```

### 3.7. Cross-Site Request Forgery (CSRF)

- **Localisation :** le middleware de session dans `backend/src/index.ts`
    ```ts
  app.use(session({
  store: new SQLiteStore({
  db: 'sessions.db',
  dir: './data',
  expires: 1 * 60 * 60, // 1 heure
  }),
  secret: 'secret-key',
  resave: false,
  saveUninitialized: false,
  name: 'session',
  }));
   ```

- **Preuve de concept :**
    1. D√©marrer l‚Äôapplication : npm run setup puis npm run dev.
    2. Lancer le fichier [evil.html](evil.html) sur le navigateur (CORS all√©g√©s avec le bon port qui va bien)
    3. On observe que le script s'ex√©cute bien et fait un POST avec un cookie qui n'est pas strict.

![cookie-samesite-no.png](screenshoots/cookie-samesite-no.png)

- **Cause :**
    - Pas de flag SameSite ni m√©canisme de jeton CSRF. Aucune route ne v√©rifie de token CSRF. Ainsi, une requ√™te
      POST/PUT/DELETE envoy√©e par un autre site utilise automatiquement le cookie de session de l‚Äôutilisateur connect√©.

- **Rem√©diation :**
    - Ajouter un middleware CSRF (ex. csurf) et passer le cookie en sameSite strict :
  ```ts
  app.use(csurf({
  cookie: {
  sameSite: 'strict',
  secure: process.env.NODE_ENV === 'production',
  httpOnly: true
  }
  }));

  app.use((req, res, next) => {
  res.cookie('XSRF-TOKEN', req.csrfToken(), {
  sameSite: 'strict',
  secure: process.env.NODE_ENV === 'production',
  httpOnly: false
  });
  next();
  });
   ```
---

### 3.8. Server‚ÄëSide Request Forgery (SSRF)